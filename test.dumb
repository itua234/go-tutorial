2. When you need to send a webhook:
Insert a row into webhook_events with status pending and attempts = 0.
3. Send the webhook (in a goroutine, background worker, or scheduled job):
Try to POST the payload to the target URL.
If it succeeds, update status to success.
If it fails, increment attempts, update last_attempt_at, and set status to failed or keep as pending for retry.
4. Retry logic:
Periodically (e.g., with a cron job or background worker), query for webhooks with status pending or failed and attempts < max_attempts.
Retry sending them.
Optionally, implement exponential backoff or delay between retries.
5. Monitor and alert:
You can monitor the table for webhooks stuck in failed status and alert if needed.

In summary:

Yes, use a DB table to track webhooks.
Insert a row for each attempt.
Retry failed ones with a background worker.
Update status and attempts on each try.
This is the industry standard for reliable webhook delivery and retry!

mkdir user-service
cd user-service
go mod init user-service
go get github.com/gin-gonic/gin


// validIdentityTypes := []string{"BVN", "NIN"}
	// found := slices.Contains(validIdentityTypes, strings.ToUpper(cust.Identity.Type))
	// if !found {
	// 	c.JSON(http.StatusBadRequest, gin.H{
	// 		"message": "Invalid identity type: " + cust.Identity.Type + ". Must be one of BVN, NIN.",
	// 		"error":   true,
	// 	})
	// 	return
	// }

	
	request, err := ctrl.kycService.FindRequestByKycToken(kycToken)
	if err != nil {
		return nil, nil, err
	}

	var request models.Request
	result := database.DB.Where("kyc_token = ?", kyc_token).First(&request)
	if result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error":   true,
			"message": "KYC request not found",
		})
		return
	} else if request.Status == "completed" {
		log.Printf("KYC request already completed: %s", kyc_token)
		c.JSON(http.StatusForbidden, gin.H{
			"error":   true,
			"message": "KYC request already completed.",
		})
		return
	} else if request.Status == "failed" {
		log.Printf("KYC request failed: %s", kyc_token)
		c.JSON(http.StatusForbidden, gin.H{
			"error":   true,
			"message": "KYC request failed. Please try again.",
		})
		return
	}

	var decrypted map[string]interface{}
	json.Unmarshal([]byte(*request.EncryptedData), &decrypted)
	var customer models.Customer
	database.DB.Preload("Identities").
		Where("email_hash = ?", utils.HashFunction(decrypted["email"].(string))).
		First(&customer)

	c.JSON(http.StatusOK, gin.H{
		"message": "KYC request fetched successfully",
		"results": gin.H{
			"redirect_url":            request.RedirectURL,
			"kyc_level":               request.KYCLevel,
			"bank_accounts_requested": request.BankAccountsRequested,
			"customer":                customer,
			"status":                  request.Status,
		},
		"error": false,
	})